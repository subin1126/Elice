1. 객체 지향 프로그래밍(OOP)의 장점
 - 프로그램을 유연하고 변경이 용이하게 만든다
 - 직관적인 코드 분석을 가능하게 한다
 - 프로그램의 개발과 보수를 간편하게 만든다
 - 코드의 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 추구한다

2. 타입스크립트 접근 제어자
 - public, protected, private

 타입스크립트에서는 접근 제어자 중 default는 없으며,
 따로 선언을 하지 않을 시 public으로 사용이 된다

3. Readonly
 - 프로퍼티를 읽기 전용 설정, 변경 불가
 - 프로퍼티들은 선언 또는 생성자에서만 초기화 가능

4. abstract 키워드는 추상 클래스 또는 추상 클래스 내에서 추상 메소드에 정의할 때 사용한다

-------------------------------------------------------------

Class
1. 객체 지향 프로그래밍(OOP)
OOP란 Object-oriented programming의 준말로 컴퓨터 프로그램을 객체의 모임으로 파악하려는 프로그래밍 패러다임입니다. 프로그래밍을 객체 단위로 나눠서 작성하는 것으로, 예를 들어 사람을 하나의 객체라고 한다면 사람을 구성하는 뇌부터 눈, 코, 입, 귀, 팔, 다리 등을 각각 나눠서 관리하고 서로 상호작용하여 결국 사람이 밥을 먹거나, 코딩을 하는 등의 동작을 하도록 만드는 것입니다.

이렇게 OOP를 적용하면 프로그램을 변경하고 싶거나, 오류를 해결할 때 모든 구조를 뜯어 고치지 않고 문제가 되는 객체만 들여다 보면 됩니다. 즉 프로그램이 유연하고 변경이 용이하며, 개발과 보수가 간편한 이점이 있습니다. 잘 나누어진 객체는 직관적인 코드 분석을 가능하게 합니다.

객체 지향의 중요한 프로그래밍 특성은 강한 응집력과 약한 결합력입니다. 응집력이란 프로그램의 한 요소가 여러 기능에 얼마만큼 책임을 지고 있는지 나타내는 것으로, 응집력이 높으면 하나의 요소가 하나의 기능을 관여하기 때문에 요소의 목표가 뚜렷하지만 응집력이 낮으면 하나의 요소가 여러 기능을 관여하는 것으로 코드를 이해하기 어렵게 됩니다. 결합력이란 프로그램이 기능을 수행하는 데 있어 여러 요소가 얼마만큼 연관이 되어 있는지 나타내는 것으로, 결합력이 낮으면 각 요소를 독립적으로 관리하기 용이하지만 결합력이 높으면 하나의 요소를 수정하기 위해 여러 요소를 모두 확인해야 합니다.

지금까시 설명한 객체를 클래스에 빗대어 다시 표현하자면 사람 클래스에서 필드(Field) 는 눈, 코, 입과 같은 신체 기관이 되는 것이고, 메소드(Method) 는 행동이 되는 것입니다. 그리고 사람이 만들어질 때 초기값을 넣기 위한 호출되는 것을 생성자(Constructor) 라고 하며 필드, 메소드, 생성자를 클래스의 멤버(Member) 라고 부릅니다. 인스턴스(Instance) 는 만들어진 각각의 사람을 나타냅니다.

클래스 문법

class 키워드를 이용해 클래스를 만들 수 있습니다.
클래스 내에서 클래스 멤버를 사용하기 위해서는 this 키워드를 사용합니다.
new 키워드를 이용해 클래스의 인스턴스를 생성합니다.
2. 접근 제어자 / 상속
접근 제어자
접근 제어자는 속성 또는 메소드로의 접근을 제어하기 위해 사용됩니다. 타입스크립트에는 3가지 접근 제어자가 존재합니다.

public
선언된 멤버를 클래스 밖에서도 자유롭게 접근할 수 있습니다.
타입스크립트의 멤버는 기본적으로 public으로 선언되지만, 명시적으로 표시해도 됩니다.
protected
멤버가 포함된 클래스와 그 하위 클래스에서만 접근할 수 있습니다.
priavte
선언된 멤버를 클래스 외부에서 접근할 수 없습니다.
상속
OOP는 상속을 이용해 존재하는 클래스를 확장해 새로운 클래스를 생성할 수 있습니다. 예를 들어 사람 클래스를 확장하여 아이, 어른, 노인과 같은 새로운 클래스를 만들 수 있습니다.

extends 키워드를 이용해 클래스를 상속하며 파생된 클래스를 하위 클래스(subclass), 기초 클래스를 상위 클래스(superclass)라고 부릅니다.

하위 클래스는 상위 클래스의 기능(메소드)을 확장합니다. 예를 들어 사람 클래스에 움직이는 기능이 있었다면, 어른과 노인 모두 똑같이 움직이는 기능을 확장하여 사용합니다. 다만, 둘의 움직이는 속도를 다르게 하는 등 세부적으로 변경하여 사용합니다.

3. Getters & Setters / readonly / static
getters & setters
비공개로 설정하려는 속성은 private로 설정하여 직접 호출하거나 수정하지 않습니다. 대신 getter / setter 함수를 사용합니다.

클래스의 멤버에 잘못된 값을 넣어 에러를 발생시키는 것을 막기 위해 이용합니다. 예를 들어 사람 클래스에 나이 속성이 있다고 할 때, 나이는 무조건 0보다 크기 때문에 getter / setter를 설정하여 0 이하의 값이 들어오는 것을 방지할 수 있습니다.

이렇게 멤버에 직접적으로 접근하지 못하도록 하는 것을 캡슐화라고 합니다.

readonly
읽기만 가능한 속성을 선언하기 위해 사용하며, 속성을 읽기 전용으로 설정해 변경할 수 없게 만듭니다. 그래서 선언될 때나 생성자에 값을 설정한 이후에는 수정이 불가능한 속성입니다.

변경될 경우가 없는 상수에 해당 키워드를 이용합니다. 비슷한 기능을 하는 const가 있는데 const는 변수 참조를 위한 것이고 readonly는 속성을 위한 것입니다.

static
객체마다 할당되지 않고 클래스의 모든 객체가 공유하는 멤버인 전역 멤버를 선언할 때 사용합니다. 따라서 인스턴스 없이도 클래스 자체에서 해당 변수를 접근할 수 있습니다.

static은 멤버를 정적으로 선언하며 클래스명.을 이용해 접근이 가능합니다.

4. 추상 클래스
추상 클래스는 다른 클래스들이 파생될 수 있는 기초 클래스로 직접 인스턴스화를 할 수 없는 클래스입니다.

abstract 키워드를 이용해 추상 클래스나 추상 메소드를 정의하며, 추상 메소드는 클래스에 구현되어 있지 않기 때문에 파생된 클래스에서 구현해야 합니다. 즉, 추상 클래스는 사용을 위해서는 상속을 강제하는 클래스입니다.

템플릿 메소드 패턴(Template Method Pattern)
템플릿 메소드 패턴은 기능의 구조만 메소드에 정의하고, 하위 클래스에서 기능의 구조는 유지한 채 세부적인 알고리즘만 재정의 하는 디자인 패턴입니다.

전체적인 구조가 동일하고, 상황에 따라 알고리즘을 확장 및 변경하기 때문에 코드 중복을 최소화할 수 있는 이점이 있습니다.

추상 클래스를 이용해 상위 클래스에서 메소드의 구조를 잡고, 하위 클래스에서 디테일한 알고리즘을 변경함으로써 템플릿 메소드 패턴을 적용할 수 있습니다.

디자인 패턴이란 소프트웨어 설계에서 공통적으로 자주 발생하는 문제들을 해결하기 위한 설계 방법을 정리한 패턴을 말합니다. 즉, 문제가 발생하지 않는 코드 작성을 위한 정형화된 방법입니다.
