1. 정규 표현식
 - 정규 표현식을 이용하면 여러 개인 정보들이 섞여 있는 문자열에서
   010으로 시작하는 휴대폰 번호만을 찾을 수 있다
 - 정규 표현식은 문자열을 검색하거나 치환할 때 사용되는 형식 언어이다
 - 정규 표현식은 흔히 정규식이라 불리며, 논리적 관계를 나타내는 기호와
   일반적인 문자를 뜻하는 나머지로 표현할 수 있다
 - 정규 표현식은 정규식 메타 문자를 사용하여 특정한 규칙을 가진 문자열의 집합을 표현하는 데
   사용하는 일종의 형식이다

2. \b?hy\w+   => 결과 : hyyyy
\b 는 띄어쓰기와 같은 단어 구분자를 의미하는데
뒤에 ? 가 붙어 띄어쓰기가 존재해도 혹은 존재하지 않아도 무관

또한 그 뒤 hy는 hy라는 문자를 포함하여야 함을 의미하는데
\s는 알파벳 대소문자, 숫자, 언더스코어(_)와의 매치로
뒤에 + 가 붙어 알파벳 대소문자나 숫자 혹은 언더스코어가
하나 이상 반복된다는 뜻을 가짐

hy가 포함되어 있고 hy이후 알파벳 대소문자 혹은 숫자 혹은 언더스코어가 하나 이상
반복되는 경우가 정답



3. grep -c love lovestory.txt
-c 옵션을 사용하였기 때문에 lovestory.txt 파일 내에서 love라는 문자열을 포함하는 줄의 개수를 출력하게 된다

4. File Redirection
- 표준 스트림은 문자열로 콘솔에 출력되도록 설정되어 있다
- File Redirection은 일반적인 표준 입력, 출력 그리고 오류를 사용하지 않고,
  다른 경로인 파일로 재지정한느 것을 뜻한다
- 발생한 오류를 원하는 파일에 출력하는 것을 File Redirection이라고 할 수 있다
- 리눅스에는 stdin(키보드 입력), stdout(화면 출력), stderr(오류 내용 출력)
  3가지의 표준 스트림이 존재한다
- >> 연산자는 파일이 존재하지 않다면 파일을 생성하고,
  파일이 존재한다면 파일내용을 지우지 않고 이어서 작성한다

5. python hello.py < input.txt >> result.txt

File Redirection은 다음과 같은 순서로 실행된다
 - input.txt의 내용을 python 파일 hello.py의 입력 스트림으로 전송
 - python 파일 hello.py 실행
 - python 파일 hello.py 의 출력 스트림을 result.txt로 변경
 - python 파일 hello.py 의 출력 스트림은 화면이 아닌 result.txt.에 저장

6. ls -al | grep usr > totaluser.txt

Pipe와 Redirection을 조합하여 다음 순서로 실행된다
 - ls -al 명령을 실행(숨겨진 파일을 포함하여 경로 안의 모든 내용으르 출력)
 - ls -al 명령의 결과를 입력 값으로 한 grep 명령어 실행
 - 'usr' 문자열을 포함하고 있는 파일과 디렉토리를 검색
 - grep 명령어의 출력 스트림은 totaluser.txt 에 저장

7. 물리적인 저장 장치인 usb를 마운트 하기 위해서는
   mount [option] [device] [directory] 명령어를 사용한다

8. 프로세스에 대한 설명
 - 리눅스 시스템 내에 메모리를 사용하고 있는 모든 프로그램을 프로세스라고 부른다
 - 모든 프로그램은 하나 이상의 프로세스를 가진다
   이때 프로세스간 부모, 자식 관계의 프로세스가 존재한다
 - 프로세스마다 식별을 위한 id가 부여된다
 - 프로세스는 커널에 의해 관리된다

9. 프로세스 메모리 구성에 대한 설명
 - 힙은 동적인 메모리 할당 영역이다
 - 함수 매개변수, 복귀 주소, 지역 변수와 같은 임시자료가 저장되는 공간은 스택영역 이다
 - 전역 변수와 정적 변수가 저장되는 공간은 데이터 영역이라고 부른다
 - 프로세스의 코드 영역은 코드 자체를 구성하는 메모리의 영역으로 하위 메모리부터 할당된다

 - 커널 주소 공간, 사용자 주소 공간으로 분리 할 수 있다
   이때 커널 부분은 사용자가 접근 할 수 없다
 - 우리가 사용할 수 있는 공간은 stack, heap, data, text 총 4영역으로
   코드를 짤 때 사용하는 argv, argc 그 외 env, etc 파일들 역시 stack 부분의 일부이다
 - 사용자 주소 공간 내에 user space 부분은 프로그램이 사용하는 라이브러리가 저장되는 공간이며,
   stack 과 heap 사이의 메모리 공간에 위치하고 있다
 - data는 Bss와 data로 구별할 수 있는데,
   간단하게 Bss는 초기화 되지 않은 정적변수들이 저장되며,
   data는 초기화 된 변수들이 저장되는 메모리 공간이다

10. 프로세스 목록을 확인하기 위해서는 ps 명령어를 사용한다
    -f 옵션을 지정하면 모든 정보를 확인할 수 있으며,
    이 밖에 현재 실행 중인 모든 프로세스 정보를 출력하는 -e 옵션 등 다양한 옵션이 있다
    프로세스를 종료시키기 위해서는 kill 명령어를 사용한다
    -9 시그널을 사용하여 프로세스를 강제종료할 수 있고
    정상 종료를 위해서는 -15 시그널을 사용한다

11. job 명렁어
 - job을 통해 프로세스를 실행할 수 있다
 - 터미널이 종료되면 job과 함께 프로세스도 종료되기 때문에 터미널에 의존적이라 할 수 있다
 - 각각의 터미널마다 job은 따로 존재한다
 - job은 백그라운드로 실행되는 작업을 보여주는 명령어
 - job은 프로세스와 달리 터미널 명령을 통한 작업만을 의미 

12. 명령어 뒤에 &을 붙이면 백그라운드에서 작업을 실행한다

13. 지정된 시간에 1회 실행되는 at과는 달리
    crontab은 지정된 시간에 따라 주기적으로 실행된다

만약 매주 월요일 오전 10시 10분에 /elice/backup.sh 을 실행해야 한다면,
10 10 * * 1 /elice/backup.sh 을 사용한다


14. 프로세스 관련 명령어
 - ps : -ef 옵션을 사용하여 현재 실행중인 프로세스의 목록을 볼 수 있다
 - jobs : 백그라운드로 진행 중인 작업 프로세스를 확인할 수 있다
 - at : 지정된 시간에 1회 실행되도록 예약해두는 작업 예약 명령어이다
 - crontab : 지정된 시간에 주기적으로 작업을 실행한다
 - 프로세스를 강제 종료하기 위해서는 kill 명령어와 함께 시그널 번호(-9), 프로세스 id가 필요하다


15. ssh에 대한 설명
 - 서버에 접속하기 위해서는 ssh [사용자명]@[아이피 혹은 서버이름 혹은 도메인] 명령어를 사용한다
 - pip 명령어 대신 apt-get 명령어로 openssh-server를 설치할 수 있다
 - ssh 서버를 실행하기 위해서는 sudo 권한을 사용하여야 한다
 - Telnet을 통해 보내지는 패킷 데이터는 암호화 되어 있지 않아
   노출 되어선 안되는 데이터가 노출되는 등 보안 상에 매우 치명적인 결함이
   존재하지만 SSH의 데이터는 암호화 되어 있어 보안성을 가지고 있다

 - ssh는 네트워크를 통해 다른 컴퓨터에 접근하고 명령을 실행할 수 있게 해주는 프로토콜이다
   리눅스 터미널을 사용하고 있는 mac은 openssh 명령어를 사용하여 타 컴퓨터에 접근이 가능하지만
   Windows 같은 경우 대표적인 ssh client인 putty를 사용하여 다른 서버에 접근할 수 있었다
   하지만 지금은 Windows 터미널인 powershell에 설치 할 수 있게 됨

16. 